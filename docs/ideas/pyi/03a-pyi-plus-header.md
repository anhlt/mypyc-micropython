# How .pyi + .h Files Combine to Generate C Source

> **Key Insight**: The `.pyi` provides the interface, the `.h` provides the implementation

## The Two-File System

```
┌─────────────────────────────────────────────────────────────────────┐
│                         YOU PROVIDE                                 │
├─────────────────────────────────┬───────────────────────────────────┤
│           lvgl.pyi              │           lvgl.h                  │
│      (Python interface)         │       (C header)                  │
├─────────────────────────────────┼───────────────────────────────────┤
│  - What functions to expose     │  - Actual C declarations          │
│  - Python-friendly types        │  - Struct definitions             │
│  - Docstrings for IDE           │  - Macros and constants           │
│  - Parameter names              │  - Full C type details            │
└─────────────────────────────────┴───────────────────────────────────┘
                    │                           │
                    │     mpy-compile-c         │
                    └─────────────┬─────────────┘
                                  │
                                  ▼
                    ┌─────────────────────────────┐
                    │      lvgl_wrapper.c         │
                    │    (generated C source)     │
                    ├─────────────────────────────┤
                    │  #include "lvgl.h"          │
                    │  // wrapper functions       │
                    │  // type conversions        │
                    │  // module registration     │
                    └─────────────────────────────┘
```

## What Each File Contributes

### The .pyi File Provides

1. **Which functions to wrap** (not all C functions, just what you need)
2. **Python-friendly signatures** (parameter names, docstrings)
3. **Type mappings** (`c_ptr[LvObj]` → `lv_obj_t*`)
4. **IDE support** (autocomplete, hover docs)

```python
# lvgl.pyi - YOU write this

__c_header__ = "lvgl.h"

@c_struct("lv_obj_t")
class LvObj:
    """Base widget type in LVGL."""
    pass

def lv_btn_create(parent: c_ptr[LvObj]) -> c_ptr[LvObj]:
    """
    Create a new button widget.
    
    Args:
        parent: Parent object to attach button to
        
    Returns:
        Pointer to the new button object
    """
    ...
```

### The .h File Provides

1. **Actual C declarations** (the real function signatures)
2. **Struct definitions** (memory layout)
3. **Macros and constants** (that get expanded)
4. **Type definitions** (typedefs, enums)

```c
// lvgl.h - from the C library (you don't modify this)

typedef struct _lv_obj_t lv_obj_t;

lv_obj_t * lv_btn_create(lv_obj_t * parent);
void lv_obj_set_size(lv_obj_t * obj, int32_t w, int32_t h);
void lv_label_set_text(lv_obj_t * obj, const char * text);
```

### The Generated C Combines Both

```c
// lvgl_wrapper.c - GENERATED by mpy-compile-c

// From .pyi: __c_header__ = "lvgl.h"
#include "py/runtime.h"
#include "lvgl.h"

// From .pyi: def lv_btn_create(parent: c_ptr[LvObj]) -> c_ptr[LvObj]
// From .h:  lv_obj_t * lv_btn_create(lv_obj_t * parent)
static mp_obj_t lv_btn_create_wrapper(mp_obj_t arg0) {
    // Type conversion: c_ptr[LvObj] → lv_obj_t*
    lv_obj_t *c_parent = mp_to_ptr(arg0);
    
    // Call actual C function (from .h)
    lv_obj_t *result = lv_btn_create(c_parent);
    
    // Type conversion: lv_obj_t* → mp_obj_t
    return ptr_to_mp((void *)result);
}
static MP_DEFINE_CONST_FUN_OBJ_1(lv_btn_create_obj, lv_btn_create_wrapper);
```

## The Generation Pipeline

```
┌──────────────────────────────────────────────────────────────────────┐
│ STEP 1: Parse .pyi                                                   │
│                                                                      │
│   lvgl.pyi ──→ ast.parse() ──→ CLibraryDef                          │
│                                    │                                 │
│                                    ├── structs: {LvObj: "lv_obj_t"}  │
│                                    ├── functions: [lv_btn_create...] │
│                                    └── callbacks: [EventCallback...] │
└──────────────────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────┐
│ STEP 2: Generate C Code                                              │
│                                                                      │
│   CLibraryDef ──→ CCodeGenerator ──→ C source strings               │
│                                                                      │
│   For each function in .pyi:                                         │
│     1. Generate wrapper function                                     │
│     2. Generate type conversions (from .pyi type hints)             │
│     3. Generate call to actual C function (name from .pyi)          │
│     4. Generate return conversion                                    │
└──────────────────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────┐
│ STEP 3: Combine with .h                                              │
│                                                                      │
│   #include "lvgl.h"  ←── from __c_header__ in .pyi                  │
│                                                                      │
│   The .h file is included at compile time, providing:               │
│     - Actual struct definitions                                      │
│     - Function prototypes (compiler validates our calls)            │
│     - Constants and macros                                           │
└──────────────────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────┐
│ STEP 4: Compile                                                      │
│                                                                      │
│   gcc -c lvgl_wrapper.c -I/path/to/lvgl/src                         │
│                                                                      │
│   The C compiler:                                                    │
│     - Reads our generated wrappers                                   │
│     - Reads lvgl.h for real declarations                            │
│     - Validates types match                                          │
│     - Produces object file                                           │
└──────────────────────────────────────────────────────────────────────┘
```

## Detailed Example

### Input Files

**lvgl.pyi** (you write):
```python
"""LVGL MicroPython bindings."""

__c_header__ = "lvgl.h"
__c_include_dirs__ = ["lib/lvgl/src"]

from mypyc_micropython.c_types import c_ptr, c_int, c_struct

@c_struct("lv_obj_t")
class LvObj:
    """Base LVGL widget object."""
    pass

def lv_obj_create(parent: c_ptr[LvObj] | None) -> c_ptr[LvObj]:
    """Create a new base object."""
    ...

def lv_obj_set_size(obj: c_ptr[LvObj], w: c_int, h: c_int) -> None:
    """Set the width and height of an object."""
    ...

def lv_obj_set_pos(obj: c_ptr[LvObj], x: c_int, y: c_int) -> None:
    """Set the position of an object relative to its parent."""
    ...

def lv_btn_create(parent: c_ptr[LvObj]) -> c_ptr[LvObj]:
    """Create a button widget."""
    ...

def lv_label_create(parent: c_ptr[LvObj]) -> c_ptr[LvObj]:
    """Create a label widget."""
    ...

def lv_label_set_text(label: c_ptr[LvObj], text: str) -> None:
    """Set the text of a label."""
    ...
```

**lvgl.h** (from LVGL library - unchanged):
```c
#ifndef LVGL_H
#define LVGL_H

#include <stdint.h>

typedef struct _lv_obj_t lv_obj_t;

// Core object functions
lv_obj_t * lv_obj_create(lv_obj_t * parent);
void lv_obj_set_size(lv_obj_t * obj, int32_t w, int32_t h);
void lv_obj_set_pos(lv_obj_t * obj, int32_t x, int32_t y);

// Button widget
lv_obj_t * lv_btn_create(lv_obj_t * parent);

// Label widget  
lv_obj_t * lv_label_create(lv_obj_t * parent);
void lv_label_set_text(lv_obj_t * obj, const char * text);

#endif
```

### Generated Output

**lvgl_wrapper.c** (generated):
```c
/*
 * LVGL MicroPython bindings.
 * 
 * Auto-generated from lvgl.pyi
 * Do not edit manually.
 */

#include "py/runtime.h"
#include "py/obj.h"
#include "lvgl.h"  // <-- from __c_header__

/* ========================================================================
 * Helper: Convert mp_obj_t to void pointer
 * ======================================================================== */
static inline void *mp_to_ptr(mp_obj_t obj) {
    if (obj == mp_const_none) return NULL;
    return MP_OBJ_TO_PTR(obj);
}

static inline mp_obj_t ptr_to_mp(void *ptr) {
    if (ptr == NULL) return mp_const_none;
    return MP_OBJ_FROM_PTR(ptr);
}

/* ========================================================================
 * Wrapper: lv_obj_create
 * Source:  def lv_obj_create(parent: c_ptr[LvObj] | None) -> c_ptr[LvObj]
 * ======================================================================== */
static mp_obj_t lv_obj_create_wrapper(mp_obj_t arg0) {
    // c_ptr[LvObj] | None -> lv_obj_t* (NULL if None)
    lv_obj_t *c_parent = (arg0 == mp_const_none) ? NULL : mp_to_ptr(arg0);
    
    // Call C function
    lv_obj_t *result = lv_obj_create(c_parent);
    
    // lv_obj_t* -> mp_obj_t
    return ptr_to_mp((void *)result);
}
static MP_DEFINE_CONST_FUN_OBJ_1(lv_obj_create_obj, lv_obj_create_wrapper);

/* ========================================================================
 * Wrapper: lv_obj_set_size
 * Source:  def lv_obj_set_size(obj: c_ptr[LvObj], w: c_int, h: c_int) -> None
 * ======================================================================== */
static mp_obj_t lv_obj_set_size_wrapper(mp_obj_t arg0, mp_obj_t arg1, mp_obj_t arg2) {
    // c_ptr[LvObj] -> lv_obj_t*
    lv_obj_t *c_obj = mp_to_ptr(arg0);
    // c_int -> int32_t
    int32_t c_w = mp_obj_get_int(arg1);
    int32_t c_h = mp_obj_get_int(arg2);
    
    // Call C function
    lv_obj_set_size(c_obj, c_w, c_h);
    
    // None return
    return mp_const_none;
}
static MP_DEFINE_CONST_FUN_OBJ_3(lv_obj_set_size_obj, lv_obj_set_size_wrapper);

/* ========================================================================
 * Wrapper: lv_obj_set_pos
 * Source:  def lv_obj_set_pos(obj: c_ptr[LvObj], x: c_int, y: c_int) -> None
 * ======================================================================== */
static mp_obj_t lv_obj_set_pos_wrapper(mp_obj_t arg0, mp_obj_t arg1, mp_obj_t arg2) {
    lv_obj_t *c_obj = mp_to_ptr(arg0);
    int32_t c_x = mp_obj_get_int(arg1);
    int32_t c_y = mp_obj_get_int(arg2);
    
    lv_obj_set_pos(c_obj, c_x, c_y);
    
    return mp_const_none;
}
static MP_DEFINE_CONST_FUN_OBJ_3(lv_obj_set_pos_obj, lv_obj_set_pos_wrapper);

/* ========================================================================
 * Wrapper: lv_btn_create
 * Source:  def lv_btn_create(parent: c_ptr[LvObj]) -> c_ptr[LvObj]
 * ======================================================================== */
static mp_obj_t lv_btn_create_wrapper(mp_obj_t arg0) {
    lv_obj_t *c_parent = mp_to_ptr(arg0);
    
    lv_obj_t *result = lv_btn_create(c_parent);
    
    return ptr_to_mp((void *)result);
}
static MP_DEFINE_CONST_FUN_OBJ_1(lv_btn_create_obj, lv_btn_create_wrapper);

/* ========================================================================
 * Wrapper: lv_label_create
 * Source:  def lv_label_create(parent: c_ptr[LvObj]) -> c_ptr[LvObj]
 * ======================================================================== */
static mp_obj_t lv_label_create_wrapper(mp_obj_t arg0) {
    lv_obj_t *c_parent = mp_to_ptr(arg0);
    
    lv_obj_t *result = lv_label_create(c_parent);
    
    return ptr_to_mp((void *)result);
}
static MP_DEFINE_CONST_FUN_OBJ_1(lv_label_create_obj, lv_label_create_wrapper);

/* ========================================================================
 * Wrapper: lv_label_set_text
 * Source:  def lv_label_set_text(label: c_ptr[LvObj], text: str) -> None
 * ======================================================================== */
static mp_obj_t lv_label_set_text_wrapper(mp_obj_t arg0, mp_obj_t arg1) {
    lv_obj_t *c_label = mp_to_ptr(arg0);
    // str -> const char*
    const char *c_text = mp_obj_str_get_str(arg1);
    
    lv_label_set_text(c_label, c_text);
    
    return mp_const_none;
}
static MP_DEFINE_CONST_FUN_OBJ_2(lv_label_set_text_obj, lv_label_set_text_wrapper);

/* ========================================================================
 * Module Definition
 * ======================================================================== */
static const mp_rom_map_elem_t lvgl_module_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_lvgl) },
    
    // Functions
    { MP_ROM_QSTR(MP_QSTR_lv_obj_create), MP_ROM_PTR(&lv_obj_create_obj) },
    { MP_ROM_QSTR(MP_QSTR_lv_obj_set_size), MP_ROM_PTR(&lv_obj_set_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_lv_obj_set_pos), MP_ROM_PTR(&lv_obj_set_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_lv_btn_create), MP_ROM_PTR(&lv_btn_create_obj) },
    { MP_ROM_QSTR(MP_QSTR_lv_label_create), MP_ROM_PTR(&lv_label_create_obj) },
    { MP_ROM_QSTR(MP_QSTR_lv_label_set_text), MP_ROM_PTR(&lv_label_set_text_obj) },
};
static MP_DEFINE_CONST_DICT(lvgl_module_globals, lvgl_module_globals_table);

const mp_obj_module_t lvgl_user_cmodule = {
    .base = { &mp_type_module },
    .globals = (mp_obj_dict_t *)&lvgl_module_globals,
};

MP_REGISTER_MODULE(MP_QSTR_lvgl, lvgl_user_cmodule);
```

**micropython.cmake** (generated):
```cmake
add_library(usermod_lvgl INTERFACE)

target_sources(usermod_lvgl INTERFACE
    ${CMAKE_CURRENT_LIST_DIR}/lvgl_wrapper.c
)

target_include_directories(usermod_lvgl INTERFACE
    ${CMAKE_CURRENT_LIST_DIR}
    lib/lvgl/src  # from __c_include_dirs__
)

target_link_libraries(usermod INTERFACE usermod_lvgl)
```

## Type Conversion Reference

How types flow from `.pyi` → generated C → actual `.h`:

| .pyi Type | Generated C Conversion | Matches .h Type |
|-----------|------------------------|-----------------|
| `c_ptr[LvObj]` | `lv_obj_t *c_x = mp_to_ptr(arg)` | `lv_obj_t *` |
| `c_int` | `int32_t c_x = mp_obj_get_int(arg)` | `int32_t` |
| `c_uint` | `uint32_t c_x = (uint32_t)mp_obj_get_int(arg)` | `uint32_t` |
| `str` | `const char *c_x = mp_obj_str_get_str(arg)` | `const char *` |
| `bool` | `bool c_x = mp_obj_is_true(arg)` | `bool` |
| `None` return | `return mp_const_none` | `void` |
| `c_ptr[T]` return | `return ptr_to_mp((void *)result)` | `T *` |
| `int` return | `return mp_obj_new_int(result)` | `int` |

## The Compiler Validates

When you compile the generated C:

```bash
gcc -c lvgl_wrapper.c -I/path/to/lvgl/src
```

The C compiler reads **both**:
1. Our generated wrapper (with calls like `lv_btn_create(c_parent)`)
2. The actual `lvgl.h` (with declaration `lv_obj_t * lv_btn_create(lv_obj_t * parent)`)

If we got the types wrong in `.pyi`, the C compiler will error:
```
error: incompatible pointer type passing 'int' to parameter of type 'lv_obj_t *'
```

This gives us **compile-time validation** that our `.pyi` matches the real `.h`.

## Summary

| File | Role | Who Writes It |
|------|------|---------------|
| `.pyi` | Defines Python interface, types, docs | You |
| `.h` | Defines actual C interface | Library author |
| Generated `.c` | Glue code connecting both | Our tool |

The `.pyi` is the **what** (what to expose to Python).
The `.h` is the **how** (how the C library actually works).
The generated `.c` is the **bridge** between them.
